/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package colorchooser;

//We did add a lot of imports for things like color, the different listeners, vector, swing tools..
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Vector;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

/**
 *
 * Color Text Panel - Rich's idea Integrated into main app (with some slight
 * code cleanup) by Ryan.
 */
public class ColorTextPanel extends javax.swing.JPanel implements ColorListener, ActionListener, KeyListener, DocumentListener {

    private Vector listeners;
    int errorDisplay = 0;//Variable to control if user wants to keep receiving annoying warning messages for invalid input.

    /**
     * Creates new form ColorTextPanel
     */
    public ColorTextPanel() {
        initComponents();
        listeners = new Vector();
        //I guess this is what college level work comes down to make everything work. The action and key listeners for the text fields similar to the ones for the sliders in ColorChooser.
        txtRed.addActionListener(this);
        txtGreen.addActionListener(this);
        txtBlue.addActionListener(this);
        txtRed.addKeyListener(this);
        txtGreen.addKeyListener(this);
        txtBlue.addKeyListener(this);
        //Document listeners are also important to help us with the validation routines outlined in RestrictedDocument/JIntegerField.
        txtRed.getDocument().addDocumentListener(this);
        txtGreen.getDocument().addDocumentListener(this);
        txtBlue.getDocument().addDocumentListener(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        txtRed = new colorchooser.JIntegerField();
        jLabel2 = new javax.swing.JLabel();
        txtGreen = new colorchooser.JIntegerField();
        jLabel3 = new javax.swing.JLabel();
        txtBlue = new colorchooser.JIntegerField();

        setLayout(new java.awt.GridLayout(3, 2, 3, 4));

        jLabel1.setText("Red:");
        add(jLabel1);
        add(txtRed);

        jLabel2.setText("Green:");
        add(jLabel2);
        add(txtGreen);

        jLabel3.setText("Blue:");
        add(jLabel3);
        add(txtBlue);
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private colorchooser.JIntegerField txtBlue;
    private colorchooser.JIntegerField txtGreen;
    private colorchooser.JIntegerField txtRed;
    // End of variables declaration//GEN-END:variables

    @Override
    //This method is called whenever the app detects a change to the value of the text field whether that be through the sliders changing or manual input.
    public void changeColor(ColorEvent ce) {
        //Netbeans got angry if there were no wrapper classes because you can't directly convert an int (the return value of getColor) to a string (the parameter for setText).
        txtRed.setText(Integer.toString(ce.getColor().getRed()));
        txtGreen.setText(Integer.toString(ce.getColor().getGreen()));
        txtBlue.setText((Integer.toString(ce.getColor().getBlue())));
    }

    //This method is unchanged from the professor's lite version of the app.
    private void fireColorEvent(ColorEvent colorEvent) {
        Vector v;
        synchronized (this) {
            v = (Vector) listeners.clone();
        }
        int size = v.size();
        for (int i = 0; i < size; i++) {
            ColorListener colorListener = (ColorListener) v.elementAt(i);
            colorListener.changeColor(colorEvent);
        }
    }

    //Adds a color listener to the vector collection.
    public void addColorListener(ColorListener colorListener) {
        listeners.addElement(colorListener);
    }

    //Removes a color listener from the vector collection.
    public void removeColorListener(ColorListener colorListener) {
        listeners.removeElement(colorListener);
    }

    @Override
    //Whenever an action is performed, immediately fire a color event.
    public void actionPerformed(ActionEvent arg0) {
        fireColorEvent();
    }

    //This public method is used to run the private method fireColorEvent using the RGB parameters. If it fails because invalid data (!=0-255), then we have a dialog box appear to warn.
    public void fireColorEvent() {
        try {
            fireColorEvent(new ColorEvent(this, new Color(txtRed.getValue(), txtGreen.getValue(), txtBlue.getValue())));
        } catch (Exception e) {
//            if (Integer.parseInt(txtBlue.getText()) > 255 || Integer.parseInt(txtBlue.getText()) < 0 || Integer.parseInt(txtGreen.getText()) > 255 || Integer.parseInt(txtGreen.getText()) < 0 || Integer.parseInt(txtRed.getText()) > 255 || Integer.parseInt(txtRed.getText()) < 0) {
            if (errorDisplay != 0) {//If user clicks no, then they won't see any more warnings for invalid data but the app will still reject it just the same.
                errorDisplay = JOptionPane.showConfirmDialog(
                        null,
                        "Please enter an integer value between 0 and 255!!",
                        "Invalid Data!",
                        JOptionPane.YES_NO_OPTION,
                        JOptionPane.WARNING_MESSAGE
                );
            }
        }
    }

    @Override
    //Some of these abstract methods are required to be here but we don't have to make them do anything.
    public void keyTyped(KeyEvent arg0) {
        fireColorEvent();
    }

    @Override
    public void keyPressed(KeyEvent arg0) {
        fireColorEvent();
    }

    @Override
    public void keyReleased(KeyEvent arg0) {
        fireColorEvent();
    }

    @Override
    public void insertUpdate(DocumentEvent arg0) {
        fireColorEvent();
    }

    @Override
    public void removeUpdate(DocumentEvent arg0) {
        fireColorEvent();
    }

    @Override
    public void changedUpdate(DocumentEvent arg0) {
//        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}
